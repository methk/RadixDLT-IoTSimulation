"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RadixUniverseConfig_1 = tslib_1.__importDefault(require("./RadixUniverseConfig"));
var RadixNodeDiscoveryFromNodeFinder_1 = tslib_1.__importDefault(require("./RadixNodeDiscoveryFromNodeFinder"));
var RadixNodeDiscoveryFromSeed_1 = tslib_1.__importDefault(require("./RadixNodeDiscoveryFromSeed"));
var RadixNodeConnection_1 = tslib_1.__importDefault(require("./RadixNodeConnection"));
var RadixUtil_1 = tslib_1.__importDefault(require("../common/RadixUtil"));
var RadixTokenManager_1 = require("../token/RadixTokenManager");
var long_1 = tslib_1.__importDefault(require("long"));
var promise_retry_1 = tslib_1.__importDefault(require("promise-retry"));
var RadixUniverse = /** @class */ (function () {
    function RadixUniverse() {
        var _this = this;
        this.initialized = false;
        this.liveNodes = [];
        this.connectedNodes = [];
        this.lastNetworkUpdate = 0;
        this.networkUpdateInterval = 1000 * 60 * 10;
        /**
         * Close all open connections
         * Recommended to call this before quitting the application, so that nodes can close the corresponding open connections as well
         */
        this.closeAllConnections = function () {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(_this.connectedNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var connection = _c.value;
                    connection.close();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
    }
    /**
     * Bootstraps the universe with a specific configuration
     * Must be called before performing any operations
     * Use one of the predefined static configurations in this class
     * @param config
     */
    RadixUniverse.prototype.bootstrap = function (config) {
        this.universeConfig = config.universeConfig;
        this.nodeDiscovery = config.nodeDiscovery;
        this.nodeRPCAddress = config.nodeRPCAddress;
        this.initialized = true;
        RadixTokenManager_1.radixTokenManager.initialize();
    };
    /**
     * Gets the universe magic byte, used mainly for generating an address from a public key
     * @returns
     */
    RadixUniverse.prototype.getMagicByte = function () {
        return this.universeConfig.getMagicByte();
    };
    RadixUniverse.prototype.loadPeersFromBootstrap = function () {
        var _this = this;
        return promise_retry_1.default(function (retry, attempt) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, error_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = this;
                        return [4 /*yield*/, this.nodeDiscovery.loadNodes()];
                    case 1:
                        _a.liveNodes = _b.sent();
                        this.lastNetworkUpdate = Date.now();
                        return [2 /*return*/, this.liveNodes];
                    case 2:
                        error_1 = _b.sent();
                        console.error(error_1);
                        retry();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); }, {
            retries: 1000,
            maxtimeout: 60000
        });
    };
    /**
     * Gets a RadixNodeConnection for a specified shard
     * Updates the node list if neccessary
     * @param shard
     * @returns node connection
     */
    RadixUniverse.prototype.getNodeConnection = function (shard) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var e_2, _a, e_3, _b;
            try {
                // Find active connection, return
                for (var _c = tslib_1.__values(_this.connectedNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    if (node.isReady() && _this.canNodeServiceShard(node.node, shard)) {
                        console.log('Got an active connection');
                        return resolve(node);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var _loop_1 = function (node) {
                if (_this.canNodeServiceShard(node.node, shard)) {
                    console.log('Got a pending connection');
                    // Wait for ready or error
                    node.on('open', function () {
                        resolve(node);
                    });
                    node.on('closed', function () {
                        resolve(_this.getNodeConnection(shard));
                    });
                    return { value: void 0 };
                }
            };
            try {
                // Failing that, find a pending node connection
                for (var _e = tslib_1.__values(_this.connectedNodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var node = _f.value;
                    var state_1 = _loop_1(node);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            // Open a new connection, return when ready
            console.log('Opening a new connection');
            _this.openNodeConnection(shard).then(function (connection) {
                if (connection) {
                    resolve(connection);
                }
                else {
                    reject("Coudln't find a node to connect to");
                }
            });
        });
    };
    RadixUniverse.prototype.openNodeConnection = function (shard) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_4, _a, _loop_2, this_1, _b, _c, node, state_2, e_4_1;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!(Date.now() - this.lastNetworkUpdate > this.networkUpdateInterval)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadPeersFromBootstrap()];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        // Randomize node order every time
                        this.liveNodes = RadixUtil_1.default.shuffleArray(this.liveNodes);
                        _loop_2 = function (node) {
                            var connection_1, error_2;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!this_1.canNodeServiceShard(node, shard)) return [3 /*break*/, 5];
                                        connection_1 = new RadixNodeConnection_1.default(node, this_1.nodeRPCAddress);
                                        this_1.connectedNodes.push(connection_1);
                                        connection_1.on('closed', function () {
                                            // Remove connection from connected nodes 
                                            var nodeIndex = _this.connectedNodes.indexOf(connection_1);
                                            if (nodeIndex > -1) {
                                                _this.connectedNodes.splice(nodeIndex, 1);
                                            }
                                        });
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, connection_1.openConnection()];
                                    case 2:
                                        _a.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        error_2 = _a.sent();
                                        console.log(error_2);
                                        return [2 /*return*/, { value: null }];
                                    case 4: return [2 /*return*/, { value: connection_1 }];
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 8, 9, 10]);
                        _b = tslib_1.__values(this.liveNodes), _c = _b.next();
                        _d.label = 4;
                    case 4:
                        if (!!_c.done) return [3 /*break*/, 7];
                        node = _c.value;
                        return [5 /*yield**/, _loop_2(node)];
                    case 5:
                        state_2 = _d.sent();
                        if (typeof state_2 === "object")
                            return [2 /*return*/, state_2.value];
                        _d.label = 6;
                    case 6:
                        _c = _b.next();
                        return [3 /*break*/, 4];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_4_1 = _d.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 10: return [2 /*return*/, null];
                }
            });
        });
    };
    RadixUniverse.prototype.canNodeServiceShard = function (node, shard) {
        if (node.system) {
            var low = long_1.default.fromValue(node.system.shards.low);
            var high = long_1.default.fromValue(node.system.shards.high);
            if (high.lessThan(low)) {
                // Wrap around
                return (shard.greaterThanOrEqual(low) || shard.lessThanOrEqual(high));
            }
            else {
                return (shard.greaterThanOrEqual(low) && shard.lessThanOrEqual(high));
            }
        }
        return false;
    };
    RadixUniverse.ALPHANET = {
        universeConfig: RadixUniverseConfig_1.default.ALPHANET,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://alphanet.radixdlt.com/node-finder', function (nodeIp) { return "https://alphanet.radixdlt.com/node/" + nodeIp + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://alphanet.radixdlt.com/node/" + nodeIp + "/rpc"; },
    };
    RadixUniverse.HIGHGARDEN = {
        universeConfig: RadixUniverseConfig_1.default.HIGHGARDEN,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://highgarden.radixdlt.com/node-finder', function (nodeIp) { return "https://highgarden.radixdlt.com/node/" + nodeIp + "/rpc"; }),
        // nodeIp => `https://highgarden.radixdlt.com/node/35.176.114.13/rpc`),
        nodeRPCAddress: function (nodeIp) { return "wss://highgarden.radixdlt.com/node/" + nodeIp + "/rpc"; },
    };
    RadixUniverse.SUNSTONE = {
        universeConfig: RadixUniverseConfig_1.default.SUNSTONE,
        nodeDiscovery: new RadixNodeDiscoveryFromNodeFinder_1.default('https://sunstone.radixdlt.com/node-finder', function (nodeIp) { return "https://" + nodeIp + "/rpc"; }),
        nodeRPCAddress: function (nodeIp) { return "wss://" + nodeIp + ":443/rpc"; },
    };
    RadixUniverse.WINTERFELL = {
        universeConfig: RadixUniverseConfig_1.default.WINTERFELL,
        nodeDiscovery: new RadixNodeDiscoveryFromSeed_1.default('http://52.190.0.18:8080/rpc'),
        nodeRPCAddress: function (nodeIp) { return "ws://" + nodeIp + ":8080/rpc"; },
    };
    RadixUniverse.WINTERFELL_LOCAL = {
        universeConfig: RadixUniverseConfig_1.default.WINTERFELL_LOCAL,
        nodeDiscovery: new RadixNodeDiscoveryFromSeed_1.default('http://localhost:8080/rpc'),
        nodeRPCAddress: function (nodeIp) { return "ws://127.0.0.1:8080/rpc"; },
    };
    return RadixUniverse;
}());
exports.default = RadixUniverse;
exports.radixUniverse = new RadixUniverse();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFkaXhVbml2ZXJzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVzL3VuaXZlcnNlL1JhZGl4VW5pdmVyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0ZBQXVEO0FBRXZELGdIQUFpRjtBQUNqRixvR0FBcUU7QUFFckUsc0ZBQXVEO0FBQ3ZELDBFQUEyQztBQUUzQyxnRUFBOEQ7QUFFOUQsc0RBQXVCO0FBQ3ZCLHdFQUF3QztBQUV4QztJQUFBO1FBQUEsaUJBa05DO1FBMUtVLGdCQUFXLEdBQUcsS0FBSyxDQUFBO1FBS2xCLGNBQVMsR0FBZ0IsRUFBRSxDQUFBO1FBQzNCLG1CQUFjLEdBQTBCLEVBQUUsQ0FBQTtRQUMxQyxzQkFBaUIsR0FBRyxDQUFDLENBQUE7UUFDckIsMEJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUE7UUFxSTlDOzs7V0FHRztRQUNJLHdCQUFtQixHQUFHOzs7Z0JBQ3pCLEtBQXlCLElBQUEsS0FBQSxpQkFBQSxLQUFJLENBQUMsY0FBYyxDQUFBLGdCQUFBLDRCQUFFO29CQUF6QyxJQUFNLFVBQVUsV0FBQTtvQkFDakIsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFBO2lCQUNyQjs7Ozs7Ozs7O1FBQ0wsQ0FBQyxDQUFBO0lBcUJMLENBQUM7SUFoS0c7Ozs7O09BS0c7SUFDSSxpQ0FBUyxHQUFoQixVQUFpQixNQUloQjtRQUNHLElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQTtRQUMzQyxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUE7UUFDekMsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFBO1FBQzNDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFBO1FBRXZCLHFDQUFpQixDQUFDLFVBQVUsRUFBRSxDQUFBO0lBQ2xDLENBQUM7SUFFRDs7O09BR0c7SUFDSSxvQ0FBWSxHQUFuQjtRQUNJLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQTtJQUM3QyxDQUFDO0lBRU8sOENBQXNCLEdBQTlCO1FBQUEsaUJBaUJDO1FBaEJHLE9BQU8sdUJBQVksQ0FDZixVQUFPLEtBQUssRUFBRSxPQUFPOzs7Ozs7d0JBRWIsS0FBQSxJQUFJLENBQUE7d0JBQWEscUJBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsRUFBQTs7d0JBQXJELEdBQUssU0FBUyxHQUFHLFNBQW9DLENBQUE7d0JBQ3JELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUE7d0JBQ25DLHNCQUFPLElBQUksQ0FBQyxTQUFTLEVBQUE7Ozt3QkFFckIsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFLLENBQUMsQ0FBQTt3QkFDcEIsS0FBSyxFQUFFLENBQUE7Ozs7O2FBRWQsRUFDRDtZQUNJLE9BQU8sRUFBRSxJQUFJO1lBQ2IsVUFBVSxFQUFFLEtBQUs7U0FDcEIsQ0FDSixDQUFBO0lBQ0wsQ0FBQztJQUdEOzs7OztPQUtHO0lBQ0kseUNBQWlCLEdBQXhCLFVBQXlCLEtBQVc7UUFBcEMsaUJBcUNDO1FBcENHLE9BQU8sSUFBSSxPQUFPLENBQXNCLFVBQUMsT0FBTyxFQUFFLE1BQU07OztnQkFDcEQsaUNBQWlDO2dCQUNqQyxLQUFtQixJQUFBLEtBQUEsaUJBQUEsS0FBSSxDQUFDLGNBQWMsQ0FBQSxnQkFBQSw0QkFBRTtvQkFBbkMsSUFBTSxJQUFJLFdBQUE7b0JBQ1gsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksS0FBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUU7d0JBQzlELE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsQ0FBQTt3QkFDdkMsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUE7cUJBQ3ZCO2lCQUNKOzs7Ozs7Ozs7b0NBR1UsSUFBSTtnQkFDWCxJQUFJLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFO29CQUM1QyxPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLENBQUE7b0JBQ3ZDLDBCQUEwQjtvQkFDMUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUU7d0JBQ1osT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO29CQUNqQixDQUFDLENBQUMsQ0FBQTtvQkFFRixJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRTt3QkFDZCxPQUFPLENBQUMsS0FBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7b0JBQzFDLENBQUMsQ0FBQyxDQUFBOztpQkFHTDtZQUNMLENBQUM7O2dCQWZELCtDQUErQztnQkFDL0MsS0FBbUIsSUFBQSxLQUFBLGlCQUFBLEtBQUksQ0FBQyxjQUFjLENBQUEsZ0JBQUE7b0JBQWpDLElBQU0sSUFBSSxXQUFBOzBDQUFKLElBQUk7OztpQkFjZDs7Ozs7Ozs7O1lBRUQsMkNBQTJDO1lBQzNDLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsQ0FBQTtZQUN2QyxLQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsVUFBVTtnQkFDM0MsSUFBSSxVQUFVLEVBQUU7b0JBQ1osT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFBO2lCQUN0QjtxQkFBTTtvQkFDSCxNQUFNLENBQUMsb0NBQW9DLENBQUMsQ0FBQTtpQkFDL0M7WUFDTCxDQUFDLENBQUMsQ0FBQTtRQUNOLENBQUMsQ0FBQyxDQUFBO0lBQ04sQ0FBQztJQUlhLDBDQUFrQixHQUFoQyxVQUNJLEtBQVc7Ozs7Ozs7NkJBRVAsQ0FBQSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQSxFQUFoRSx3QkFBZ0U7d0JBQ2hFLHFCQUFNLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxFQUFBOzt3QkFBbkMsU0FBbUMsQ0FBQTs7O3dCQUd2QyxrQ0FBa0M7d0JBQ2xDLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFBOzRDQUU1QyxJQUFJOzs7Ozs2Q0FDUCxPQUFLLG1CQUFtQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBckMsd0JBQXFDO3dDQUMvQixlQUFhLElBQUksNkJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQUssY0FBYyxDQUFDLENBQUE7d0NBQ3JFLE9BQUssY0FBYyxDQUFDLElBQUksQ0FBQyxZQUFVLENBQUMsQ0FBQTt3Q0FFcEMsWUFBVSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUU7NENBQ3BCLDBDQUEwQzs0Q0FDMUMsSUFBTSxTQUFTLEdBQUcsS0FBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsWUFBVSxDQUFDLENBQUE7NENBQ3pELElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dEQUNoQixLQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7NkNBQzNDO3dDQUNMLENBQUMsQ0FBQyxDQUFBOzs7O3dDQUdFLHFCQUFNLFlBQVUsQ0FBQyxjQUFjLEVBQUUsRUFBQTs7d0NBQWpDLFNBQWlDLENBQUE7Ozs7d0NBRWpDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBSyxDQUFDLENBQUE7dUVBQ1gsSUFBSTsyRUFHUixZQUFVOzs7Ozs7Ozs7d0JBcEJOLEtBQUEsaUJBQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQTs7Ozt3QkFBdEIsSUFBSTtzREFBSixJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkF3QmYsc0JBQU8sSUFBSSxFQUFBOzs7O0tBQ2Q7SUFZTywyQ0FBbUIsR0FBM0IsVUFBNEIsSUFBZSxFQUFFLEtBQVc7UUFDcEQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2IsSUFBTSxHQUFHLEdBQUcsY0FBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUNsRCxJQUFNLElBQUksR0FBRyxjQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1lBRXBELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsY0FBYztnQkFDZCxPQUFPLENBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQy9ELENBQUE7YUFDSjtpQkFBTTtnQkFDSCxPQUFPLENBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQy9ELENBQUE7YUFDSjtTQUNKO1FBRUQsT0FBTyxLQUFLLENBQUE7SUFDaEIsQ0FBQztJQS9NYSxzQkFBUSxHQUFHO1FBQ3JCLGNBQWMsRUFBRSw2QkFBbUIsQ0FBQyxRQUFRO1FBQzVDLGFBQWEsRUFBRSxJQUFJLDBDQUFnQyxDQUMvQywyQ0FBMkMsRUFDM0MsVUFBQSxNQUFNLElBQUksT0FBQSx3Q0FBc0MsTUFBTSxTQUFNLEVBQWxELENBQWtELENBQUM7UUFDakUsY0FBYyxFQUFFLFVBQUEsTUFBTSxJQUFJLE9BQUEsc0NBQW9DLE1BQU0sU0FBTSxFQUFoRCxDQUFnRDtLQUM3RSxDQUFBO0lBRWEsd0JBQVUsR0FBRztRQUN2QixjQUFjLEVBQUUsNkJBQW1CLENBQUMsVUFBVTtRQUM5QyxhQUFhLEVBQUUsSUFBSSwwQ0FBZ0MsQ0FDL0MsNkNBQTZDLEVBQzdDLFVBQUEsTUFBTSxJQUFJLE9BQUEsMENBQXdDLE1BQU0sU0FBTSxFQUFwRCxDQUFvRCxDQUFDO1FBQy9ELHVFQUF1RTtRQUMzRSxjQUFjLEVBQUUsVUFBQSxNQUFNLElBQUksT0FBQSx3Q0FBc0MsTUFBTSxTQUFNLEVBQWxELENBQWtEO0tBRS9FLENBQUE7SUFFYSxzQkFBUSxHQUFHO1FBQ3JCLGNBQWMsRUFBRSw2QkFBbUIsQ0FBQyxRQUFRO1FBQzVDLGFBQWEsRUFBRSxJQUFJLDBDQUFnQyxDQUMvQywyQ0FBMkMsRUFDM0MsVUFBQSxNQUFNLElBQUksT0FBQSxhQUFXLE1BQU0sU0FBTSxFQUF2QixDQUF1QixDQUFDO1FBQ3RDLGNBQWMsRUFBRSxVQUFBLE1BQU0sSUFBSSxPQUFBLFdBQVMsTUFBTSxhQUFVLEVBQXpCLENBQXlCO0tBQ3RELENBQUE7SUFFYSx3QkFBVSxHQUFHO1FBQ3ZCLGNBQWMsRUFBRSw2QkFBbUIsQ0FBQyxVQUFVO1FBQzlDLGFBQWEsRUFBRSxJQUFJLG9DQUEwQixDQUFDLDZCQUE2QixDQUFDO1FBQzVFLGNBQWMsRUFBRSxVQUFBLE1BQU0sSUFBSSxPQUFBLFVBQVEsTUFBTSxjQUFXLEVBQXpCLENBQXlCO0tBQ3RELENBQUE7SUFFYSw4QkFBZ0IsR0FBRztRQUM3QixjQUFjLEVBQUUsNkJBQW1CLENBQUMsZ0JBQWdCO1FBQ3BELGFBQWEsRUFBRSxJQUFJLG9DQUEwQixDQUFDLDJCQUEyQixDQUFDO1FBQzFFLGNBQWMsRUFBRSxVQUFBLE1BQU0sSUFBSSxPQUFBLHlCQUF5QixFQUF6QixDQUF5QjtLQUN0RCxDQUFBO0lBNEtMLG9CQUFDO0NBQUEsQUFsTkQsSUFrTkM7a0JBbE5vQixhQUFhO0FBb05yQixRQUFBLGFBQWEsR0FBRyxJQUFJLGFBQWEsRUFBRSxDQUFBIn0=